/****** Object:  StoredProcedure [Config].[sp_CheckExecutionStatus]    Script Date: 3/13/2025 11:31:37 AM ******/
DROP PROCEDURE [Config].[sp_CheckExecutionStatus]
GO

/****** Object:  StoredProcedure [Config].[sp_CheckExecutionStatus]    Script Date: 3/13/2025 11:31:37 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [Config].[sp_CheckExecutionStatus]  
@Execution_ID INT
AS  
BEGIN
DECLARE @Execution_Status VARCHAR(100)
	IF EXISTS (SELECT TOP 1 1 FROM [Config].ExecutionMaster e
	JOIN [Config].ExecutionDetailsPipeline ep on e.Execution_ID = ep.Execution_ID
	JOIN [Config].ExecutionStatus sta on sta.Execution_StatusID = ep.Execution_StatusID
	WHERE sta.Execution_Status='Failed'
	AND e.Execution_ID=@Execution_ID)
	BEGIN 
		SET @Execution_Status ='Failed'
	END

	SELECT @Execution_Status AS 'ExecutionStatus'
END

GO


---------------------------------
/****** Object:  StoredProcedure [Config].[sp_CheckPipelineStatus]    Script Date: 3/13/2025 11:32:09 AM ******/
DROP PROCEDURE [Config].[sp_CheckPipelineStatus]
GO

/****** Object:  StoredProcedure [Config].[sp_CheckPipelineStatus]    Script Date: 3/13/2025 11:32:09 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Config].[sp_CheckPipelineStatus]  
@Execution_PipelineID INT
AS  
BEGIN  
 SELECT sta.Execution_Status as 'ExecutionStatus'   
 FROM [Config].ExecutionDetailsPipeline pip  
 JOIN [Config].ExecutionStatus sta   
  ON pip.Execution_StatusID=sta.Execution_StatusID  
	AND pip.Execution_PipelineID=@Execution_PipelineID  
 
END

GO


--------------------
/****** Object:  StoredProcedure [Config].[sp_GetActiveSourceList]    Script Date: 3/13/2025 11:32:28 AM ******/
DROP PROCEDURE [Config].[sp_GetActiveSourceList]
GO

/****** Object:  StoredProcedure [Config].[sp_GetActiveSourceList]    Script Date: 3/13/2025 11:32:28 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Config].[sp_GetActiveSourceList]
@Source_Name VARCHAR(250)
AS
BEGIN
	SELECT Integration_ID as 'Integration_ID',
	Source_Name
	FROM [Config].IntegrationSystem
	WHERE IntegrationEnabled=1 AND Source_Name=@Source_Name
END

GO



-----------------------------
/****** Object:  StoredProcedure [Config].[sp_getauditingdata]    Script Date: 3/13/2025 11:32:45 AM ******/
DROP PROCEDURE [Config].[sp_getauditingdata]
GO

/****** Object:  StoredProcedure [Config].[sp_getauditingdata]    Script Date: 3/13/2025 11:32:45 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [Config].[sp_getauditingdata]
(
@Source Varchar(500)
)
AS
BEGIN


select * into #Executionstatus from (
SELECT e.Execution_ID,ROW_NUMBER() over(partition by e.integration_id order by execution_id desc) rnk,I.Source_Name 
       from [Config].ExecutionMaster e 
	   join [Config].IntegrationSystem i
	   on e.Integration_Id=i.Integration_ID

)a 
where rnk=1

IF @Source=''
BEGIN

select  RANK() Over(ORDER BY d.SequenceNumber ASC) AS [S.NO],d.DataPipeline_Phase [Step Name],est.Execution_Status [Status],CONCAT(c.Starttime,' ') [Start Time (EST)]
,CONCAT(c.Endtime,' ') [End Time (EST)]
,c.File_count [File Count],c.row_count [Row Count],concat(c.timtaken_minutes,' mins') [Time Taken]  
--,Concat(Toatltime,' mins') [Total Time]
from [Config].DataPipeline d join (
select i.Source_name,edp.datapipeline_id,FORMAT(SUM(inserted_rows), N'N0') as row_count,COUNT(DataPipelineTableMapping_ID) File_count 
,DATEDIFF(MINUTE,edp.Starttime,edp.Endtime) timtaken_minutes,DATEDIFF(MINUTE,e.Starttime,e.Endtime) Toatltime,edp.Execution_StatusID
,edp.Starttime,edp.Endtime
from [Config].ExecutionDetailsPipelineTables tbl
right join [Config].ExecutionDetailsPipeline edp
on tbl.Execution_PipelineID=edp.Execution_PipelineID
join [Config].ExecutionMaster E
on E.Execution_ID=edp.Execution_ID
JOIN #Executionstatus EST
on EST.Execution_ID=EDP.Execution_ID
join [Config].IntegrationSystem i
on i.Integration_ID=E.Integration_ID
group by edp.datapipeline_id,edp.Starttime,edp.Endtime,e.Starttime,e.Endtime,edp.Execution_StatusID,i.Source_name)c
on c.datapipeline_id=d.DataPipeline_ID
join [Config].ExecutionStatus est
on est.Execution_StatusID=c.Execution_StatusID
order by c.Source_Name,d.SequenceNumber

END
ELSE 
BEGIN

select RANK() Over(ORDER BY d.SequenceNumber ASC) AS [S.NO],d.DataPipeline_Phase [Step Name],est.Execution_Status [Status],CONCAT(c.Starttime,' ') [Start Time (EST)]
,CONCAT(c.Endtime,' ') [End Time (EST)]
,c.File_count [File Count],c.row_count [Row Count],concat(c.timtaken_minutes,' mins') [Time Taken]  
--,Concat(Toatltime,' mins') [Total Time]
from [Config].DataPipeline d join (
select i.Source_name,edp.datapipeline_id,FORMAT(SUM(inserted_rows), N'N0') as row_count,COUNT(DataPipelineTableMapping_ID) File_count 
,DATEDIFF(MINUTE,edp.Starttime,edp.Endtime) timtaken_minutes,DATEDIFF(MINUTE,e.Starttime,e.Endtime) Toatltime,edp.Execution_StatusID
,edp.Starttime,edp.Endtime
from [Config].ExecutionDetailsPipelineTables tbl
right join [Config].ExecutionDetailsPipeline edp
on tbl.Execution_PipelineID=edp.Execution_PipelineID
join [Config].ExecutionMaster E
on E.Execution_ID=edp.Execution_ID
JOIN #Executionstatus EST
on EST.Execution_ID=EDP.Execution_ID
join [Config].IntegrationSystem i
on i.Integration_ID=E.Integration_ID
AND i.Source_Name=@Source
group by edp.datapipeline_id,edp.Starttime,edp.Endtime,e.Starttime,e.Endtime,edp.Execution_StatusID,i.Source_name)c
on c.datapipeline_id=d.DataPipeline_ID
join [Config].ExecutionStatus est
on est.Execution_StatusID=c.Execution_StatusID
order by c.Source_Name,d.SequenceNumber

END



--select i.Source_name [Source],d.DataPipeline_Phase [Step Name],concat('[',ts.SchemaName,'].[',tt.TableName,']') [Target File],est.Execution_Status [Status],c.Starttime,c.Endtime
--,c.File_count [File Count],c.row_count [Row Count],concat(c.timtaken_minutes,' mins') [Time Taken]  
----,Concat(Toatltime,' mins') [Total Time]
--from DataPipeline d join (
--select edp.datapipeline_id,tbl.DataPipelineTableMapping_ID,FORMAT(SUM(inserted_rows), N'N0') as row_count,COUNT(DataPipelineTableMapping_ID) File_count 
--,DATEDIFF(MINUTE,edp.Starttime,edp.Endtime) timtaken_minutes,DATEDIFF(MINUTE,e.Starttime,e.Endtime) Toatltime,edp.Execution_StatusID
--,edp.Starttime,edp.Endtime
--from ExecutionDetailsPipelineTables tbl
--join ExecutionDetailsPipeline edp
--on tbl.Execution_PipelineID=edp.Execution_PipelineID
--join ExecutionMaster E
--on E.Execution_ID=edp.Execution_ID
--JOIN #Executionstatus EST
--on EST.Execution_ID=EDP.Execution_ID
--group by edp.datapipeline_id,edp.Starttime,edp.Endtime,e.Starttime,e.Endtime,edp.Execution_StatusID)c
--on c.datapipeline_id=d.DataPipeline_ID
--join IntegrationSystem i
--on i.Integration_ID=d.Integration_ID
--join ExecutionStatus est
--on est.Execution_StatusID=c.Execution_StatusID
--AND i.Source_Name=@Source
--join DataPipelineTableMapping dpt
--on dpt.DataPipelineTableMapping_ID=c.DataPipelineTableMapping_ID
--join SchemaList ts
--on ts.SchemaList_ID=dpt.TargetSchema_ID
--join TableList tt
--on tt.TableList_ID=dpt.TargetTable_ID
--order by i.Source_Name

END
GO



---------------------------------------
/****** Object:  StoredProcedure [Config].[sp_getColumnMapping]    Script Date: 3/13/2025 11:33:03 AM ******/
DROP PROCEDURE [Config].[sp_getColumnMapping]
GO

/****** Object:  StoredProcedure [Config].[sp_getColumnMapping]    Script Date: 3/13/2025 11:33:03 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Config].[sp_getColumnMapping]          
  @DataPipeline_ID INT,          
  @SourceTable_Name VARCHAR(100),      
  @SourceSchema_Name VARCHAR(100),    
  @TargetTable_Name VARCHAR(100),      
  @TargetSchema_Name VARCHAR(100)     
AS          
BEGIN          
  DECLARE @json_construct varchar(MAX) = '{"type": "TabularTranslator", "mappings": {X}}';          
  DECLARE @json VARCHAR(MAX);          
              
  SET @json = (          
    SELECT          
	c.[SourceColumn_Name] AS 'source.name',           
	c.[TargetColumn_Name] AS 'sink.name'           
	FROM [Config].DataPipelineTableMapping as tblmap    
	 JOIN [Config].PipelineMetadata as c on tblmap.DataPipelineTableMapping_ID=c.DataPipelineTableMapping_ID
	 JOIN [Config].SchemaList sch on tblmap.SourceSchema_ID= sch.SchemaList_ID 
	 JOIN [Config].TableList tbl on tblmap.SourceTable_ID = tbl.TableList_ID 
	 JOIN [Config].SchemaList sch1 on tblmap.TargetSchema_ID =sch1.SchemaList_ID 
	 JOIN [Config].TableList tbl1 on tblmap.TargetTable_ID =tbl1.TableList_ID        
   WHERE tblmap.[DataPipeline_ID] = @DataPipeline_ID          
   AND tbl.TableName = @SourceTable_Name          
   AND sch.SchemaName = @SourceSchema_Name    
   AND tbl1.TableName = @TargetTable_Name          
   AND sch1.SchemaName = @TargetSchema_Name      
   AND c.[MetadataEnabled]= 1            
    FOR JSON PATH );          
           
    SELECT REPLACE(@json_construct,'{X}', @json) AS json_output;          
END

GO



---------------

/****** Object:  StoredProcedure [Config].[sp_getauditingdataExecutionid]    Script Date: 3/13/2025 11:33:48 AM ******/
DROP PROCEDURE [Config].[sp_getauditingdataExecutionid]
GO

/****** Object:  StoredProcedure [Config].[sp_getauditingdataExecutionid]    Script Date: 3/13/2025 11:33:48 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [Config].[sp_getauditingdataExecutionid]
(
@Source Varchar(500)
)
AS
BEGIN


select * into #Executionstatus from (
SELECT e.Execution_ID,ROW_NUMBER() over(partition by e.integration_id order by execution_id desc) rnk,I.Source_Name 
       from [Config].ExecutionMaster e 
	   join [Config].IntegrationSystem i
	   on e.Integration_Id=i.Integration_ID
	   and i.Source_Name=@Source

)a 
where rnk=1


SELECT TOP 1 Execution_ID FROM #Executionstatus ORDER BY Execution_ID DESC



END

GO


-----------------------

/****** Object:  StoredProcedure [Config].[sp_getauditingdataTotaltime]    Script Date: 3/13/2025 11:35:36 AM ******/
DROP PROCEDURE [Config].[sp_getauditingdataTotaltime]
GO

/****** Object:  StoredProcedure [Config].[sp_getauditingdataTotaltime]    Script Date: 3/13/2025 11:35:36 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [Config].[sp_getauditingdataTotaltime]
(
@Source Varchar(500)
)
AS
BEGIN


select * into #Executionstatus from (
SELECT e.Execution_ID,ROW_NUMBER() over(partition by e.integration_id order by execution_id desc) rnk,I.Source_Name 
       from [Config].ExecutionMaster e 
	   join [Config].IntegrationSystem i
	   on e.Integration_Id=i.Integration_ID
	   and i.Source_Name=@Source

)a 
where rnk=1


select distinct Concat(Toatltime,' mins') [Total Time]
from DataPipeline d join (
select edp.datapipeline_id,FORMAT(SUM(inserted_rows), N'N0') as row_count,COUNT(DataPipelineTableMapping_ID) File_count 
,DATEDIFF(MINUTE,edp.Starttime,edp.Endtime) timtaken_minutes,DATEDIFF(MINUTE,e.Starttime,e.Endtime) Toatltime,edp.Execution_StatusID
,edp.Starttime,edp.Endtime
from [Config].ExecutionDetailsPipelineTables tbl
join [Config].ExecutionDetailsPipeline edp
on tbl.Execution_PipelineID=edp.Execution_PipelineID
join [Config].ExecutionMaster E
on E.Execution_ID=edp.Execution_ID
JOIN #Executionstatus EST
on EST.Execution_ID=EDP.Execution_ID
group by edp.datapipeline_id,edp.Starttime,edp.Endtime,e.Starttime,e.Endtime,edp.Execution_StatusID)c
on c.datapipeline_id=d.DataPipeline_ID
join [Config].IntegrationSystem i
on i.Integration_ID=d.Integration_ID
join [Config].ExecutionStatus est
on est.Execution_StatusID=c.Execution_StatusID
AND i.Source_Name=@Source



END

GO



--------------------------------
/****** Object:  StoredProcedure [Config].[sp_getColumnMapping]    Script Date: 3/13/2025 11:35:52 AM ******/
DROP PROCEDURE [Config].[sp_getColumnMapping]
GO

/****** Object:  StoredProcedure [Config].[sp_getColumnMapping]    Script Date: 3/13/2025 11:35:52 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Config].[sp_getColumnMapping]          
  @DataPipeline_ID INT,          
  @SourceTable_Name VARCHAR(100),      
  @SourceSchema_Name VARCHAR(100),    
  @TargetTable_Name VARCHAR(100),      
  @TargetSchema_Name VARCHAR(100)     
AS          
BEGIN          
  DECLARE @json_construct varchar(MAX) = '{"type": "TabularTranslator", "mappings": {X}}';          
  DECLARE @json VARCHAR(MAX);          
              
  SET @json = (          
    SELECT          
	c.[SourceColumn_Name] AS 'source.name',           
	c.[TargetColumn_Name] AS 'sink.name'           
	FROM [Config].DataPipelineTableMapping as tblmap    
	 JOIN [Config].PipelineMetadata as c on tblmap.DataPipelineTableMapping_ID=c.DataPipelineTableMapping_ID
	 JOIN [Config].SchemaList sch on tblmap.SourceSchema_ID= sch.SchemaList_ID 
	 JOIN [Config].TableList tbl on tblmap.SourceTable_ID = tbl.TableList_ID 
	 JOIN [Config].SchemaList sch1 on tblmap.TargetSchema_ID =sch1.SchemaList_ID 
	 JOIN [Config].TableList tbl1 on tblmap.TargetTable_ID =tbl1.TableList_ID        
   WHERE tblmap.[DataPipeline_ID] = @DataPipeline_ID          
   AND tbl.TableName = @SourceTable_Name          
   AND sch.SchemaName = @SourceSchema_Name    
   AND tbl1.TableName = @TargetTable_Name          
   AND sch1.SchemaName = @TargetSchema_Name      
   AND c.[MetadataEnabled]= 1            
    FOR JSON PATH );          
           
    SELECT REPLACE(@json_construct,'{X}', @json) AS json_output;          
END

GO



-----------------------------------

/****** Object:  StoredProcedure [Config].[sp_getexecutionid]    Script Date: 3/13/2025 11:36:08 AM ******/
DROP PROCEDURE [Config].[sp_getexecutionid]
GO

/****** Object:  StoredProcedure [Config].[sp_getexecutionid]    Script Date: 3/13/2025 11:36:08 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [Config].[sp_getexecutionid] 
	-- Add the parameters for the stored procedure here
    @DataPipeline_ID INT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @Execution_id INT;
	DECLARE @Execution_previousid INT;
	DECLARE @Integration_ID INT;

		SELECT @Integration_ID=Integration_ID FROM [Config].DataPipeline WHERE DataPipeline_ID=@DataPipeline_ID
		SELECT @Execution_id=MAX(Execution_ID) FROM [Config].ExecutionMaster WHERE Integration_ID=@Integration_ID

		--CHECK IN THE CURRENT EXECUTION SOURCE TO RAW IS AVAILABLE OR NOT
		SELECT E.*  
		   INTO #Source_files
			FROM [Config].ExecutionDetailsPipeline E 
			JOIN [Config].DataPipeline DP 
			ON E.DataPipeline_ID=DP.DataPipeline_ID
			AND DP.DataPipeline_Phase='Source_To_Raw'
			AND E.Execution_ID=@Execution_id
			JOIN [Config].ExecutionStatus ES 
					ON ES.Execution_StatusID=E.Execution_StatusID
					AND ES.Execution_Status='Success'



			--IF Source_To_Raw IS NOT AVILABLE IN THE CURRENT EXECUTION TAKE THE PREVIOUS Source_To_Raw SUCCESSFULL EXECUTIONID
        IF NOT EXISTS (SELECT * FROM #Source_files)
		 BEGIN
			SELECT @Execution_previousid=MAX(E.Execution_ID)
			        FROM [Config].ExecutionDetailsPipeline E 
			        JOIN [Config].DataPipeline DP 
			        ON E.DataPipeline_ID=DP.DataPipeline_ID
			        AND DP.DataPipeline_Phase='Source_To_Raw'
                    JOIN [Config].ExecutionMaster EM 
					ON EM.Execution_ID=E.Execution_ID
					AND EM.Integration_ID=@Integration_ID
					JOIN [Config].ExecutionStatus ES 
					ON ES.Execution_StatusID=E.Execution_StatusID
					AND ES.Execution_Status='Success'

					SELECT  ISNULL(@Execution_previousid,@Execution_id) AS Execution_ID 

		 END
		 ELSE 
		 BEGIN
		 SELECT @Execution_id AS Execution_ID
		 END


END

GO



-------------------------------------
/****** Object:  StoredProcedure [Config].[sp_getIntegrationName]    Script Date: 3/13/2025 11:36:22 AM ******/
DROP PROCEDURE [Config].[sp_getIntegrationName]
GO

/****** Object:  StoredProcedure [Config].[sp_getIntegrationName]    Script Date: 3/13/2025 11:36:22 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Config].[sp_getIntegrationName]        
  @Integration_ID INT        
AS        
BEGIN        
              
   SELECT ist.Source_Name AS 'Source_Name'
   FROM [Config].IntegrationSystem ist       
   WHERE ist.Integration_ID =@Integration_ID   

       
END

GO


-----------------------------------------------
/****** Object:  StoredProcedure [Config].[sp_getPipelinesList]    Script Date: 3/13/2025 11:36:44 AM ******/
DROP PROCEDURE [Config].[sp_getPipelinesList]
GO

/****** Object:  StoredProcedure [Config].[sp_getPipelinesList]    Script Date: 3/13/2025 11:36:44 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Config].[sp_getPipelinesList]        
  @Integration_ID INT        
AS        
BEGIN        

SET NOCOUNT ON;
    DECLARE @Execution_id INT;
    DECLARE @Execution_Status Nvarchar(200);
	SELECT @Execution_id=MAX(Execution_ID)
	                                   FROM [Config].ExecutionMaster E 
	                                        JOIN [Config].ExecutionStatus ES
											ON ES.Execution_StatusID=E.Execution_StatusID
											AND ES.Execution_Status<>'Running'
											where Integration_ID=@Integration_ID

	SELECT @Execution_Status=es.Execution_Status FROM [Config].ExecutionMaster E 
	      INNER JOIN [Config].ExecutionStatus ES
		        ON  E.Execution_StatusID=ES.Execution_StatusID
		        AND E.Execution_ID=@Execution_id
		        AND Integration_ID=@Integration_ID

IF @Execution_Status<>'Success'
BEGIN
  SELECT E.*,ES.Execution_Status,ROW_NUMBER() over(order by execution_pipelineID desc) AS Rnk,D.SequenceNumber
       into #Failed_ExecutionDetailsPipeline 
	      FROM [Config].ExecutionDetailsPipeline E 
	      INNER JOIN [Config].ExecutionStatus ES
		  ON E.Execution_StatusID=ES.Execution_StatusID
		  AND E.Execution_ID=@Execution_id
		  INNER JOIN [Config].DataPipeline D 
		  ON D.DataPipeline_ID=E.DataPipeline_ID
		  AND ES.Execution_Status<>'Success'
		  /*NESTED IF ELSE STARTS*/
		  IF EXISTS (SELECT DISTINCT 1 FROM #Failed_ExecutionDetailsPipeline)
		    BEGIN
		         SELECT D.DataPipeline_ID AS 'DataPipeline_ID',
                          D.DataPipeline_Name,
						  D.TargetFolder
						  from #Failed_ExecutionDetailsPipeline FE
		                     INNER JOIN [Config].DataPipeline D
					         ON D.SequenceNumber>=FE.SequenceNumber
					         AND D.Integration_ID=@Integration_ID
							 AND D.PipelineEnabled=1
							 ORDER BY D.SequenceNumber
             END
		    ELSE
		      BEGIN
			           SELECT dp.DataPipeline_ID AS 'DataPipeline_ID',
                                        dp.DataPipeline_Name,
										dp.TargetFolder
                                        FROM [Config].IntegrationSystem ist    
                                        JOIN [Config].DataPipeline dp    
                                        ON ist.Integration_ID = dp.Integration_ID    
                                        WHERE ist.Integration_ID =@Integration_ID  AND PipelineEnabled=1  
										ORDER BY SequenceNumber
			  END
			  /*NESTED IF ELSE ENDING*/

       END   
	   ELSE
	    BEGIN
			     SELECT dp.DataPipeline_ID AS 'DataPipeline_ID',
                                        dp.DataPipeline_Name,
										dp.TargetFolder
                                        FROM [Config].IntegrationSystem ist    
                                        JOIN [Config].DataPipeline dp    
                                        ON ist.Integration_ID = dp.Integration_ID    
                                        WHERE ist.Integration_ID =@Integration_ID  AND PipelineEnabled=1  
										ORDER BY SequenceNumber
	    END

       
END

GO


------------------------------------------------
/****** Object:  StoredProcedure [Config].[sp_getSourceObject]    Script Date: 3/13/2025 11:37:02 AM ******/
DROP PROCEDURE [Config].[sp_getSourceObject]
GO

/****** Object:  StoredProcedure [Config].[sp_getSourceObject]    Script Date: 3/13/2025 11:37:02 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Config].[sp_getSourceObject]                
  @DataPipeline_ID INT                
AS                
BEGIN   
  
    DECLARE @Execution_id INT;  
    DECLARE @Execution_Status Nvarchar(200);  
 DECLARE @Execution_Pipelineid INT;  
 DECLARE @Execution_PipelineStatus Nvarchar(200);  
 DECLARE @Integration_ID INT;  
 DECLARE @DataPipeline_Phase VARCHAR(500);  
    DECLARE @TargetFolder VARCHAR(255);  
  
   
 SELECT @Integration_ID=Integration_ID,@DataPipeline_Phase=DataPipeline_Phase FROM [Config].DataPipeline WHERE DataPipeline_ID=@DataPipeline_ID  
  
 SELECT @Execution_id=MAX(Execution_ID)  
                                    FROM [Config].ExecutionMaster E   
                                         JOIN [Config].ExecutionStatus ES  
           ON ES.Execution_StatusID=E.Execution_StatusID  
           AND ES.Execution_Status<>'Running'  
           where Integration_ID=@Integration_ID  
  
  
     SELECT @Execution_Status=es.Execution_Status FROM [Config].ExecutionMaster E   
               INNER JOIN [Config].ExecutionStatus ES  
                 ON  E.Execution_StatusID=ES.Execution_StatusID  
                 AND E.Execution_ID=@Execution_id  
                 AND Integration_ID=@Integration_ID  
  
 SELECT @Execution_Pipelineid=Execution_PipelineID,@Execution_PipelineStatus=ES.Execution_Status  
       FROM [Config].ExecutionDetailsPipeline E   
       INNER JOIN [Config].ExecutionStatus ES  
    ON E.Execution_StatusID=ES.Execution_StatusID  
    AND E.Execution_ID=@Execution_id  
    AND E.DataPipeline_ID=@DataPipeline_ID  
                    
  
IF @Execution_Status NOT IN ('Success') AND @Execution_PipelineStatus NOT IN ('Success') AND @DataPipeline_Phase NOT IN ('Source_To_Raw')  
BEGIN  
SELECT E.*  
         INTO #Failed_Tables  
       FROM [Config].ExecutionDetailsPipelineTables E   
       INNER JOIN [Config].ExecutionStatus ES  
    ON E.Execution_StatusID=ES.Execution_StatusID  
    AND E.Execution_PipelineID=@Execution_Pipelineid  
    AND ES.Execution_Status<>'Success'  
  
    IF EXISTS (SELECT * FROM #Failed_Tables )  
      BEGIN  
     SELECT DISTINCT                
                  @DataPipeline_ID AS 'Datapipeline_ID',                
                  sch.[SchemaName] AS 'SourceSchema',              
                  tbl.[TableName] AS 'SourceTable',            
                  sch1.[SchemaName] AS 'TargetSchema',            
                  tbl1.[TableName] AS 'TargetTable',     
                  tblmap.DataPipelineTableMapping_ID as 'DataPipelineTableMapping_ID',  
      tblmap.SequenceNumber AS 'SequenceNumber',  
      tblmap.Child_Pipeline AS 'Child_Pipeline',  
      dp.TargetFolder AS 'TargetFolder',
	  tblmap.QueryText AS 'QueryText'
  
                    FROM [Config].DataPipeline as dp                
                 LEFT JOIN [Config].DataPipelineTableMapping as tblmap on dp.DataPipeline_ID=tblmap.DataPipeline_ID         
                 LEFT JOIN [Config].SchemaList sch on tblmap.SourceSchema_ID= sch.SchemaList_ID         
                 LEFT JOIN [Config].TableList tbl on tblmap.SourceTable_ID = tbl.TableList_ID         
                 LEFT JOIN [Config].SchemaList sch1 on tblmap.TargetSchema_ID =sch1.SchemaList_ID         
                 LEFT JOIN [Config].TableList tbl1 on tblmap.TargetTable_ID =tbl1.TableList_ID   
     JOIN #Failed_Tables ft on ft.DataPipelineTableMapping_ID=tblmap.DataPipelineTableMapping_ID  
     and ft.Execution_PipelineID=@Execution_Pipelineid  
                         
                  WHERE dp.[DataPipeline_ID] = @DataPipeline_ID                
                    AND dp.PipelineEnabled= 1 -- Enabled on pipeline level    
                 AND tblmap.IsEnabled=1 -- Enable on table level    
                 ORDER BY tblmap.SequenceNumber  -- Sequence to Load tables  
  
   END  
   ELSE  
   BEGIN  
                SELECT                 
                    @DataPipeline_ID AS 'Datapipeline_ID',                
                    sch.[SchemaName] AS 'SourceSchema',              
                    tbl.[TableName] AS 'SourceTable',            
                    sch1.[SchemaName] AS 'TargetSchema',            
                    tbl1.[TableName] AS 'TargetTable',     
                tblmap.DataPipelineTableMapping_ID as 'DataPipelineTableMapping_ID',  
     tblmap.Child_Pipeline AS 'Child_Pipeline',  
     dp.TargetFolder AS 'TargetFolder',
	  tblmap.QueryText AS 'QueryText'  
  
                      FROM [Config].DataPipeline as dp                
                   LEFT JOIN [Config].DataPipelineTableMapping as tblmap on dp.DataPipeline_ID=tblmap.DataPipeline_ID         
                   LEFT JOIN [Config].SchemaList sch on tblmap.SourceSchema_ID= sch.SchemaList_ID         
                   LEFT JOIN [Config].TableList tbl on tblmap.SourceTable_ID = tbl.TableList_ID         
                   LEFT JOIN [Config].SchemaList sch1 on tblmap.TargetSchema_ID =sch1.SchemaList_ID         
                   LEFT JOIN [Config].TableList tbl1 on tblmap.TargetTable_ID =tbl1.TableList_ID         
                           
                    WHERE dp.[DataPipeline_ID] = @DataPipeline_ID                
                      AND dp.PipelineEnabled= 1 -- Enabled on pipeline level    
                   AND tblmap.IsEnabled=1 -- Enable on table level    
                   ORDER BY tblmap.SequenceNumber  -- Sequence to Load tables    
  
   END  
  
  END  
   ELSE   
     BEGIN  
  
       SELECT                 
          @DataPipeline_ID AS 'Datapipeline_ID',                
          sch.[SchemaName] AS 'SourceSchema',              
          tbl.[TableName] AS 'SourceTable',            
          sch1.[SchemaName] AS 'TargetSchema',            
          tbl1.[TableName] AS 'TargetTable',     
          tblmap.DataPipelineTableMapping_ID as 'DataPipelineTableMapping_ID',  
    tblmap.Child_Pipeline AS 'Child_Pipeline',  
    dp.TargetFolder AS 'TargetFolder' ,
	  tblmap.QueryText AS 'QueryText'
	
  
            FROM [Config].DataPipeline as dp                
         LEFT JOIN [Config].DataPipelineTableMapping as tblmap on dp.DataPipeline_ID=tblmap.DataPipeline_ID         
         LEFT JOIN [Config].SchemaList sch on tblmap.SourceSchema_ID= sch.SchemaList_ID         
         LEFT JOIN [Config].TableList tbl on tblmap.SourceTable_ID = tbl.TableList_ID         
         LEFT JOIN [Config].SchemaList sch1 on tblmap.TargetSchema_ID =sch1.SchemaList_ID         
         LEFT JOIN [Config].TableList tbl1 on tblmap.TargetTable_ID =tbl1.TableList_ID         
                 
          WHERE dp.[DataPipeline_ID] = @DataPipeline_ID                
            AND dp.PipelineEnabled= 1 -- Enabled on pipeline level    
         AND tblmap.IsEnabled=1 -- Enable on table level    
         ORDER BY tblmap.SequenceNumber  -- Sequence to Load tables    
 END  
END 

GO



------------------------------------------------------------
/****** Object:  StoredProcedure [Config].[sp_getWaterMarkDetails]    Script Date: 3/13/2025 11:37:22 AM ******/
DROP PROCEDURE [Config].[sp_getWaterMarkDetails]
GO

/****** Object:  StoredProcedure [Config].[sp_getWaterMarkDetails]    Script Date: 3/13/2025 11:37:22 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO




CREATE PROCEDURE [Config].[sp_getWaterMarkDetails]          
  @DataPipeline_ID INT,          
  @SourceTable_Name VARCHAR(100),      
  @SourceSchema_Name VARCHAR(100),
  @IntegrationID INT
AS  
BEGIN            
  DECLARE @WhereClause varchar(MAX) = '';            
  DECLARE @WaterMarkColumn VARCHAR(50);       
  DECLARE @LastLoad DATE;  
  DECLARE @Success_flag INT;  
  DECLARE @Loaddate_start DATETIME;  
  DECLARE @Loaddate_end DATETIME;  
  DECLARE @Execution_ID INT;  
  DECLARE @Status_Execution_ID INT;  
  DECLARE @Status NVARCHAR(50);  
  DECLARE @Failed_Loaddate_start DATETIME;  
  DECLARE @Partitioncolumn VARCHAR(50);
  DECLARE @OrderByColumn VARCHAR(50);
  DECLARE @Table_query1 NVARCHAR(MAX);  
  DECLARE @Table_query2 NVARCHAR(MAX);  
  DECLARE @Table_query NVARCHAR(MAX);  
 

 DECLARE @Integration_groupby int ;
 
 select @Integration_groupby = (select integration_groupby from [Config].IntegrationSystem where Integration_ID= @IntegrationID)

 CREATE TABLE #ALLINTEGRATIONID(IntegrationId INT) INSERT INTO  #ALLINTEGRATIONID(IntegrationId) SELECT Integration_ID FROM [Config].IntegrationSystem WHERE integration_groupby=@Integration_groupby

  SET @WaterMarkColumn = (            
    SELECT            
 c.SourceColumn_Name   
 FROM [Config].DataPipelineTableMapping as tblmap      
  JOIN [Config].PipelineMetadata as c on tblmap.DataPipelineTableMapping_ID=c.DataPipelineTableMapping_ID  
  JOIN [Config].SchemaList sch on tblmap.SourceSchema_ID= sch.SchemaList_ID   
  JOIN [Config].TableList tbl on tblmap.SourceTable_ID = tbl.TableList_ID   
   WHERE tblmap.[DataPipeline_ID] = @DataPipeline_ID            
   AND tbl.TableName = @SourceTable_Name            
   AND sch.SchemaName = @SourceSchema_Name      
   AND c.[MetadataEnabled]= 1      
   AND c.[WaterMarkColumn] = 1);      
  
 set @Partitioncolumn=
(   SELECT            
 c.SourceColumn_Name   
 FROM [Config].DataPipelineTableMapping as tblmap      
  JOIN [Config].PipelineMetadata as c on tblmap.DataPipelineTableMapping_ID=c.DataPipelineTableMapping_ID  
  JOIN [Config].SchemaList sch on tblmap.SourceSchema_ID= sch.SchemaList_ID   
  JOIN [Config].TableList tbl on tblmap.SourceTable_ID = tbl.TableList_ID   
   WHERE tblmap.[DataPipeline_ID] = @DataPipeline_ID            
   AND tbl.TableName = @SourceTable_Name            
   AND sch.SchemaName = @SourceSchema_Name      
   AND c.[MetadataEnabled]= 1      
   AND c.[PartitionByColumn] = 1);

 SET @OrderByColumn = (            
    SELECT            
 c.SourceColumn_Name   
 FROM [Config].DataPipelineTableMapping as tblmap      
  JOIN [Config].PipelineMetadata as c on tblmap.DataPipelineTableMapping_ID=c.DataPipelineTableMapping_ID  
  JOIN [Config].SchemaList sch on tblmap.SourceSchema_ID= sch.SchemaList_ID   
  JOIN [Config].TableList tbl on tblmap.SourceTable_ID = tbl.TableList_ID   
   WHERE tblmap.[DataPipeline_ID] = @DataPipeline_ID            
   AND tbl.TableName = @SourceTable_Name            
   AND sch.SchemaName = @SourceSchema_Name      
   AND c.[MetadataEnabled]= 1      
   AND c.[OrderByColumn] = 1);



       
    IF @WaterMarkColumn <> ''  
 BEGIN  
  
    SELECT @Execution_ID =  MAX(Execution_ID)  
                            FROM [Config].ExecutionMaster E   
          INNER JOIN [Config].ExecutionStatus ES    
          ON E.Execution_StatusID=ES.Execution_StatusID  
		  INNER JOIN #ALLINTEGRATIONID AID
		  ON E.Integration_ID=AID.IntegrationId
   
          SELECT @Loaddate_start=MAX(Starttime) FROM [Config].ExecutionMaster WHERE Execution_ID=@Execution_ID  
  
          SELECT  @Status_Execution_ID = MAX(IC.Execution_id)  
                            FROM [Config].ExecutionMaster E   
          INNER JOIN [Config].ExecutionStatus ES    
          ON E.Execution_StatusID=ES.Execution_StatusID  
          INNER JOIN [Config].Incremental_condition IC  
          ON IC.Execution_id=E.Execution_ID 
		  INNER JOIN #ALLINTEGRATIONID AID
		  ON E.Integration_ID=AID.IntegrationId
  
          SELECT  @Status = ES.Execution_Status,@Failed_Loaddate_start=IC.Starttime,@Loaddate_end=IC.Enddatetime  
                            FROM [Config].ExecutionMaster E   
          INNER JOIN [Config].ExecutionStatus ES    
          ON E.Execution_StatusID=ES.Execution_StatusID  
          INNER JOIN [Config].Incremental_condition IC  
          ON IC.Execution_id=E.Execution_ID  
		  INNER JOIN #ALLINTEGRATIONID AID
		  ON E.Integration_ID=AID.IntegrationId
          WHERE  E.Execution_ID=@Status_Execution_ID    
          
 IF NOT EXISTS (SELECT 1 FROM [Config].Incremental_condition WHERE Execution_id=@Execution_ID)  
 BEGIN  
    --IF NOT EXISTS (SELECT 1 FROM Incremental_condition where Execution_id in (select Execution_id from ExecutionMaster where Integration_ID=@IntegrationID))  
   IF NOT EXISTS (SELECT 1 FROM [Config].Incremental_condition where Execution_id in (select Execution_id from [Config].ExecutionMaster E INNER JOIN #ALLINTEGRATIONID AID ON E.Integration_ID=AID.IntegrationId ))  
    BEGIN  
    INSERT INTO [Config].Incremental_condition(Execution_id,Starttime,Enddatetime)  
    SELECT @Execution_ID,NULL,@Loaddate_start  
    END  
    ELSE IF @Status='Success'  
    BEGIN  
      
  
    INSERT INTO [Config].Incremental_condition(Execution_id,Starttime,Enddatetime)  
    SELECT @Execution_ID,@Loaddate_end,@Loaddate_start  
  
    END  
    ELSE   
    BEGIN  
  
    INSERT INTO [Config].Incremental_condition(Execution_id,Starttime,Enddatetime)  
    SELECT @Execution_ID,@Failed_Loaddate_start,@Loaddate_end  
  
    END   
     END       
   IF EXISTS (SELECT 1 FROM [Config].Incremental_condition WHERE Execution_id=@Execution_ID AND Starttime IS NULL)  
   BEGIN  
        SELECT @WhereClause=CONCAT('WHERE ',@WaterMarkColumn ,' < ''' , CONVERT(VARCHAR(100), MAX(Enddatetime), 21),'''')   
                     FROM [Config].Incremental_condition WHERE Execution_id=@Execution_ID  
  
     
  
   END  
   ELSE   
   BEGIN  
  
     SELECT @WhereClause=CONCAT('WHERE ',@WaterMarkColumn ,' > ''' , CONVERT(VARCHAR(100), MAX(Starttime), 21),'''',' AND '  
                   ,@WaterMarkColumn,' < ''',CONVERT(VARCHAR(100), MAX(Enddatetime), 21),'''')   
             FROM [Config].Incremental_condition WHERE Execution_id=@Execution_ID      
   END  
    END  
 ELSE  
 BEGIN  
  SET @WhereClause = ''  
 END  




  if(@Partitioncolumn <> '' and @OrderByColumn <> '')
 begin
 if(@WhereClause<>'')
 begin
 set @Table_Query1= N';With cte as
(
select *,Row_number() over (Partition by '+ @Partitioncolumn+' order by '+@OrderByColumn+' desc) rnk from '+@SourceSchema_Name+'.'+@SourceTable_Name+')
select * from cte where rnk=1 AND ' +replace(@WhereClause,'WHERE','')
end
else
begin
 set @Table_Query1= N';With cte as
(
select *,Row_number() over (Partition by '+ @Partitioncolumn+' order by '+@OrderByColumn+' desc) rnk from '+@SourceSchema_Name+'.'+@SourceTable_Name+')
select * from cte where rnk=1'
end

 end

  
 
 SET @Table_query2=CONCAT('SELECT * FROM [',@SourceSchema_Name,'].[',@SourceTable_Name,'] ',@WhereClause);  

  
if(@Table_query1<>'')
 begin
  set @Table_query=@Table_query1
 end
 else
 begin
  set @Table_query=@Table_query2
 end  
   SELECT @Table_query Query;  
  
END  

GO



------------------------------------------------------
/****** Object:  StoredProcedure [Config].[sp_logExecutionIntegration]    Script Date: 3/13/2025 11:37:41 AM ******/
DROP PROCEDURE [Config].[sp_logExecutionIntegration]
GO

/****** Object:  StoredProcedure [Config].[sp_logExecutionIntegration]    Script Date: 3/13/2025 11:37:41 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [Config].[sp_logExecutionIntegration] 
	-- Add the parameters for the stored procedure here
	@Status varchar(100),
	@IntegrationID int,
	@ExecutionID int=NULL,
	@ErrorMessage varchar(500)=NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF @Status='Running'
		BEGIN

			 INSERT INTO [Config].ExecutionMaster(Integration_ID,Execution_Date,Starttime,Execution_StatusID,ErrorMessage)
			 select @IntegrationID,GETDATE(),GETDATE(),Execution_StatusID,NULL from [Config].ExecutionStatus
			 where Execution_Status=@Status
			 SELECT SCOPE_IDENTITY() as 'Execution_ID'

		END 
	  ELSE IF @Status='Success'
		BEGIN

			 UPDATE e  SET Endtime=GETDATE(),E.Execution_StatusID=ES.Execution_StatusID,ErrorMessage=NULL
			 FROM [Config].ExecutionMaster e 
			 INNER JOIN [Config].ExecutionStatus ES
			 ON ES.Execution_Status=@Status
			 WHERE Execution_ID=@ExecutionID

		 END
	  ELSE IF @Status='Failed'
		 BEGIN

			 UPDATE E SET Endtime=GETDATE(),E.Execution_StatusID=ES.Execution_StatusID,ErrorMessage=@ErrorMessage
			  FROM [Config].ExecutionMaster e 
			 INNER JOIN [Config].ExecutionStatus ES
			 ON ES.Execution_Status=@Status
			 WHERE Execution_ID=@ExecutionID

	      END


END
GO


--------------------------------------------
/****** Object:  StoredProcedure [Config].[sp_logExecutionPipeline]    Script Date: 3/13/2025 11:38:05 AM ******/
DROP PROCEDURE [Config].[sp_logExecutionPipeline]
GO

/****** Object:  StoredProcedure [Config].[sp_logExecutionPipeline]    Script Date: 3/13/2025 11:38:05 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

-- =============================================  
-- Author:  <Author,,Name>  
-- Create date: <Create Date,,>  
-- Description: <Description,,>  
-- =============================================  
CREATE PROCEDURE [Config].[sp_logExecutionPipeline]   
 -- Add the parameters for the stored procedure here  
 @Status varchar(100),  
 @ExecutionPipelineID int=NULL,  
 @ExecutionID int,  
 @DataPipeLineID int,  
 @ErrorMessage varchar(500)=NULL  
AS  
BEGIN  
 -- SET NOCOUNT ON added to prevent extra result sets from  
 -- interfering with SELECT statements.  
 SET NOCOUNT ON;  
  
 IF @Status='Running'  
  BEGIN  
  
    INSERT INTO [Config].ExecutionDetailsPipeline(Execution_ID,DataPipeline_ID,Starttime,Execution_StatusID,ErrorMessage)  
    SELECT @ExecutionID,@DataPipeLineID,GETDATE(),Execution_StatusID,NULL FROM [Config].ExecutionStatus  
    WHERE Execution_Status=@Status  
	SELECT SCOPE_IDENTITY() as 'Execution_PipelineID'  
  
  END   
     ELSE IF @Status='Success'  
  BEGIN  
  
    UPDATE E SET Endtime=GETDATE(),E.Execution_StatusID=ES.Execution_StatusID,ErrorMessage=NULL  
    FROM [Config].ExecutionDetailsPipeline E  
    INNER JOIN [Config].ExecutionStatus ES  
    ON ES.Execution_Status=@Status  
    WHERE Execution_PipelineID=@ExecutionPipelineID  
  
  END  
     ELSE IF @Status='Failed'  
  BEGIN  
  
    UPDATE E SET Endtime=GETDATE(),E.Execution_StatusID=ES.Execution_StatusID,ErrorMessage=@ErrorMessage  
     FROM [Config].ExecutionDetailsPipeline E  
    INNER JOIN [Config].ExecutionStatus ES  
    ON ES.Execution_Status=@Status  
    WHERE Execution_PipelineID=@ExecutionPipelineID  
  
     END  
  
  
END  
GO


------------------------------------------------------
/****** Object:  StoredProcedure [Config].[sp_logExecutionTableMapping]    Script Date: 3/13/2025 11:38:20 AM ******/
DROP PROCEDURE [Config].[sp_logExecutionTableMapping]
GO

/****** Object:  StoredProcedure [Config].[sp_logExecutionTableMapping]    Script Date: 3/13/2025 11:38:20 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [Config].[sp_logExecutionTableMapping] 
	-- Add the parameters for the stored procedure here
	@Status varchar(100),
	@ExecutionPipelineTablesID int=NULL,
	@ExecutionPipelineID int,
	@DataPipelineTableMapping_ID int,
	@ErrorMessage varchar(500)=NULL,
	@Inserted_Rows int=null,
	@Updated_Rows int =null

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF @Status='Running'
		BEGIN

			 INSERT INTO [Config].ExecutionDetailsPipelineTables(Execution_PipelineID,DataPipelineTableMapping_ID,Starttime,Execution_StatusID,ErrorMessage,Inserted_Rows,Updated_Rows)
			 SELECT @ExecutionPipelineID,@DataPipelineTableMapping_ID,GETDATE(),Execution_StatusID,NULL,@Inserted_Rows,@Updated_Rows FROM [Config].ExecutionStatus
			 WHERE Execution_Status=@Status
			 
			 SELECT SCOPE_IDENTITY() AS 'Execution_PipelineTablesID'

		END 
	    ELSE IF @Status='Success'
		BEGIN

			 UPDATE E SET Endtime=GETDATE(),E.Execution_StatusID=ES.Execution_StatusID,ErrorMessage=NULL,Inserted_Rows=@Inserted_Rows,Updated_Rows=@Updated_Rows
			 FROM [Config].ExecutionDetailsPipelineTables E
			 INNER JOIN [Config].ExecutionStatus ES
			 ON ES.Execution_Status=@Status
			 WHERE Execution_PipelineTablesID=@ExecutionPipelineTablesID

		END
	    ELSE IF @Status='Failed'
		BEGIN

			 UPDATE E SET Endtime=GETDATE(),E.Execution_StatusID=ES.Execution_StatusID,ErrorMessage=@ErrorMessage
			  FROM [Config].ExecutionDetailsPipelineTables E
			 INNER JOIN [Config].ExecutionStatus ES
			 ON ES.Execution_Status=@Status
			 WHERE Execution_PipelineTablesID=@ExecutionPipelineTablesID

	    END


END
GO


----------------------------------------------
/****** Object:  StoredProcedure [Config].[sp_RaiseError]    Script Date: 3/13/2025 11:38:37 AM ******/
DROP PROCEDURE [Config].[sp_RaiseError]
GO

/****** Object:  StoredProcedure [Config].[sp_RaiseError]    Script Date: 3/13/2025 11:38:37 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Config].[sp_RaiseError]   
 @ExecutionPipelineID INT,
 @IsPipeline BIT
AS    
BEGIN  
DECLARE @ErrorMessage VARCHAR(500) 
IF (@IsPipeline=0)
	BEGIN
		SET @ErrorMessage = 
			(SELECT TOP 1 tbl.ErrorMessage 
			FROM [Config].ExecutionDetailsPipelineTables tbl  
			INNER JOIN [Config].ExecutionStatus es      
			ON tbl.Execution_StatusID = es.Execution_StatusID  
			WHERE tbl.Execution_PipelineID=@ExecutionPipelineID  
			AND es.Execution_Status='Failed')

			RAISERROR(@ErrorMessage, 17, 1);  
	END

ELSE IF (@IsPipeline=1)
	BEGIN
		SET @ErrorMessage = 
			(SELECT TOP 1 pip.ErrorMessage  
			FROM [Config].ExecutionDetailsPipeline pip  
			JOIN [Config].ExecutionStatus sta   
				ON pip.Execution_StatusID=sta.Execution_StatusID  
			WHERE pip.Execution_PipelineID=@ExecutionPipelineID
			AND Execution_Status='Failed')

			RAISERROR(@ErrorMessage, 17, 1);  
	END

END

GO


------------------------------------------------------
/****** Object:  StoredProcedure [Config].[sp_Truncatetables]    Script Date: 3/13/2025 11:38:53 AM ******/
DROP PROCEDURE [Config].[sp_Truncatetables]
GO

/****** Object:  StoredProcedure [Config].[sp_Truncatetables]    Script Date: 3/13/2025 11:38:53 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [Config].[sp_Truncatetables]
(
@DataPipelineid INT
)
AS
BEGIN
Declare @Truncate Nvarchar(max);

 set @Truncate=(SELECT 
    STRING_AGG(Concat('Truncate table ',SchemaName,'.',TableName), '; ') AS CombinedColumn
FROM 
    (select distinct s.SchemaName,T.TableName from Config.DataPipelineTableMapping D
	join Config.TableList t on t.TableList_ID=d.TargetTable_ID
join Config.SchemaList s on s.SchemaList_ID=d.TargetSchema_ID
 where DataPipeline_ID=@DataPipelineid)a)
 
 Select @Truncate as Truncatequery
END
GO



----------------------------------------
/****** Object:  StoredProcedure [Config].[usp_GetFunctionRuleList]    Script Date: 3/13/2025 11:39:07 AM ******/
DROP PROCEDURE [Config].[usp_GetFunctionRuleList]
GO

/****** Object:  StoredProcedure [Config].[usp_GetFunctionRuleList]    Script Date: 3/13/2025 11:39:07 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [Config].[usp_GetFunctionRuleList] 
	-- Add the parameters for the stored procedure here
@Tablename varchar(500),
@Integrationname varchar(500)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT vr.RuleID,VR.Code,vr.[Description],vm.SourceTable,vm.TargetTable,vm.ColumnName,vm.ValidationErrorColumn,
	VM.ComparisonColumns
,VM.IsAdditionalColumn
,VM.IsAdditionalCondition
,VM.SequenceNumber
,VM.SequenceOperator
,VM.COMPARISONOPERATOR
,VM.LOGICALOPERATOR
,VM.COMPARISONVALUE
,VM.FUNCTIONPARAMS
,VM.JOINS
,VM.Example
,VM.RuleGroup
from [Config].[ValidationRule] vr
	INNER JOIN [Config].[ValidationRuleMapping] vm
	on vr.RuleID=vm.RuleID
	inner join [Config].IntegrationSystem I
	ON VM.Integration_ID=I.Integration_ID
	where SourceTable=@tablename AND I.Source_Name=@Integrationname AND vm.IsEnabled=1
	order by vr.RuleID
END
GO


------------------------------------------------------------
/****** Object:  StoredProcedure [Config].[USP_Insert_pipelinemetadata]    Script Date: 3/13/2025 11:39:25 AM ******/
DROP PROCEDURE [Config].[USP_Insert_pipelinemetadata]
GO

/****** Object:  StoredProcedure [Config].[USP_Insert_pipelinemetadata]    Script Date: 3/13/2025 11:39:25 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


-- =============================================
-- Author:    
-- Create date: <2021-06-18 12:46:41.293>
-- Description:  
-- =============================================
CREATE PROCEDURE [Config].[USP_Insert_pipelinemetadata]
  -- Add the parameters for the stored procedure here
  @Datapipelineid  INT,
  @Sourcetablename NVARCHAR(max),
  @targettablename NVARCHAR(max)
AS
  BEGIN
      -- SET NOCOUNT ON added to prevent extra result sets from
      -- interfering with SELECT statements.
      SET nocount ON;

      IF Object_id('tempdb..#SourceTablelist') IS NOT NULL
        DROP TABLE #sourcetablelist;

      CREATE TABLE #sourcetablelist
        (
           tableid                INT IDENTITY(1, 1),
           tablename              VARCHAR(800),
           schemaname             VARCHAR(200),
           tablenamewithoutschema VARCHAR(200),
           insertionflag          INT
        );

      --Splitting the @Sourcetablename  comma seperated values into a table.
      INSERT INTO #sourcetablelist
                  (tablename,
                   schemaname,
                   tablenamewithoutschema,
                   insertionflag)
      SELECT value                                         tablename,
             Substring(value, 0, Charindex('.', value, 0)) schemaname,
             Substring(value, Charindex('.', value, 0) + 1, Len(value))
             tablenamewithoutschema,
             1                                             Insertionflag
      FROM   String_split(@Sourcetablename, ',');

      IF Object_id('tempdb..#targetTablelist') IS NOT NULL
        DROP TABLE #targettablelist;

      CREATE TABLE #targettablelist
        (
           tableid                INT IDENTITY(1, 1),
           tablename              VARCHAR(800),
           schemaname             VARCHAR(200),
           tablenamewithoutschema VARCHAR(200),
           insertionflag          INT
        );

      --Splitting the @targettablename  comma seperated values into a table.
      INSERT INTO #targettablelist
                  (tablename,
                   schemaname,
                   tablenamewithoutschema,
                   insertionflag)
      SELECT value                                         tablename,
             Substring(value, 0, Charindex('.', value, 0)) schemaname,
             Substring(value, Charindex('.', value, 0) + 1, Len(value))
             tablenamewithoutschema,
             1                                             Insertionflag
      FROM   String_split(@targettablename, ',');
	  
      --insert the target database table defnition into [Config].[Metadata_Source_schema]
      INSERT INTO [Config].[metadata_source_schema]
      SELECT s.TABLE_SCHEMA
              ,s.TABLE_NAME
              ,s.COLUMN_NAME
      FROM   information_schema.columns s
             INNER JOIN #targettablelist t
                     ON s.table_schema = t.schemaname
                        AND s.table_name = t.tablenamewithoutschema

      INSERT INTO [Config].[metadata_source_schema]
      SELECT s.TABLE_SCHEMA
              ,s.TABLE_NAME
              ,s.COLUMN_NAME
      FROM   information_schema.columns s
             INNER JOIN #sourcetablelist t
                     ON s.table_schema = t.schemaname
                        AND s.table_name = t.tablenamewithoutschema

      SELECT *
      FROM   #sourcetablelist

      SELECT *
      FROM   #targettablelist

      --To get the schemaid and tableid for the given tables 
      SELECT @Datapipelineid Datapipelineid,
             *
      INTO   #pipelinmapping
      FROM   (SELECT s.schemalist_id  SR_SchemaList_ID,
                     S.schemaname     SR_SchemaName,
                     tbl.tablelist_id SR_TableList_ID,
                     tbl.tablename    SR_tablename,
                     t.tableid        SR_tableid
              FROM   #sourcetablelist T
                     INNER JOIN [Config].[schemalist] S
                             ON T.schemaname = S.schemaname
                     INNER JOIN [Config].[tablelist] tbl
                             ON tbl.tablename = t.tablenamewithoutschema)SR
             INNER JOIN (SELECT s.schemalist_id  TR_SchemaList_ID,
                                S.schemaname     TR_SchemaName,
                                tbl.tablelist_id TR_TableList_ID,
                                tbl.tablename    TR_tablename,
                                t.tableid        TR_tableid
                         FROM   #targettablelist T
                                INNER JOIN [Config].[schemalist] S
                                        ON T.schemaname = S.schemaname
                                INNER JOIN [Config].[tablelist] tbl
                                        ON
                                tbl.tablename = t.tablenamewithoutschema)TR
                     ON SR.sr_tableid = TR.tr_tableid

      --to get the maximum sequence number at datapipeline_id level 
      DECLARE @max_sequencenumber INT

      SELECT @max_sequencenumber = Max(sequencenumber)
      FROM   datapipelinetablemapping
      WHERE  datapipeline_id = @Datapipelineid

      --SELECT *
      --FROM   #pipelinmapping

      ---- inserting the data into DataPipelineTableMapping table and checking for 
      --insert into DataPipelineTableMapping(DataPipeline_ID,SourceSchema_ID,SourceTable_ID,TargetSchema_ID,TargetTable_ID,QueryText,SequenceNumber,IsEnabled)
      INSERT INTO DataPipelineTableMapping
                  (datapipeline_id,
                   sourceschema_id,
                   sourcetable_id,
                   targetschema_id,
                   targettable_id,
                   querytext,
                   sequencenumber,
                   isenabled)
      SELECT DISTINCT datapipelineid,
                      sr_schemalist_id,
                      sr_tablelist_id,
                      tr_schemalist_id,
                      tr_tablelist_id,
                      '',
					  isnull(@max_sequencenumber,0)+ Row_number() OVER(ORDER BY p.sr_tablelist_id),
                      1                
      FROM   #pipelinmapping P
      WHERE  NOT EXISTS (SELECT *
                         FROM   DataPipelineTableMapping DP
                         WHERE  P.Datapipelineid=DP.DataPipeline_ID AND 
                          DP.sourceschema_id = P.sr_schemalist_id
                          AND DP.sourcetable_id = P.sr_tablelist_id
                          AND DP.targetschema_id = P.tr_schemalist_id
                          AND DP.targettable_id = P.tr_tablelist_id)

      ----- for the given combination fetching the DataPipelineTableMapping_ID,source_column,targetcolumn name and inserting into PipelineMetadata
      --insert into PipelineMetadata(DataPipelineTableMapping_ID,SourceColumn_Name,TargetColumn_Name,WaterMarkColumn,MetadataEnabled)
      INSERT INTO PipelineMetadata
                  (datapipelinetablemapping_id,
                   sourcecolumn_name,
                   targetcolumn_name,
                   watermarkcolumn,
				   PartitionByColumn,
                   OrderByColumn,
                   metadataenabled)
      SELECT DISTINCT 	  DP.datapipelinetablemapping_id,
                      c.column_name  source_column_name,
                      Tc.column_name target_column_name,
                      0,
					  0,
					  0,
                      1
      FROM   DataPipelineTableMapping DP
             INNER JOIN #pipelinmapping P
                     ON P.datapipelineid = DP.datapipeline_id
                        AND DP.sourceschema_id = P.sr_schemalist_id
                        AND DP.sourcetable_id = P.sr_tablelist_id
                        AND DP.targetschema_id = P.tr_schemalist_id
                        AND DP.targettable_id = P.tr_tablelist_id
             INNER JOIN [Config].[metadata_source_schema] C
                     ON c.table_name = p.sr_tablename
                        AND p.sr_schemaname = c.table_schema
             INNER JOIN [Config].[metadata_source_schema] tc
                     ON tc.table_name = P.tr_tablename
                        AND tc.table_schema  = p.tr_schemaname
                        AND tc.column_name = c.column_name
      WHERE  NOT EXISTS (SELECT *
                         FROM   PipelineMetadata PP
                         WHERE
      PP.datapipelinetablemapping_id = DP.datapipelinetablemapping_id)

      --SELECT *
      --FROM   DataPipelineTableMapping

      --SELECT *
      --FROM   PipelineMetadata
  END


GO


---------------------------------------------------
/****** Object:  StoredProcedure [Config].[USP_Insert_pipelineTables]    Script Date: 3/13/2025 11:39:43 AM ******/
DROP PROCEDURE [Config].[USP_Insert_pipelineTables]
GO

/****** Object:  StoredProcedure [Config].[USP_Insert_pipelineTables]    Script Date: 3/13/2025 11:39:43 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

-- =============================================
-- Author:      <Author, , Name>
-- Create Date: <Create Date, , >
-- Description: <Description, , >
-- =============================================
CREATE PROCEDURE [Config].[USP_Insert_pipelineTables]
(
    -- Add the parameters for the stored procedure here
    @DataPipeline_ID INT
)
AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON

	--Insert the Tables which are not present in Tablelist Table 
	insert into [Config].TableList(TableName)
	SELECT distinct  table_name FROM [Config].[Metadata_Source_schema] WHERE TABLE_NAME NOT IN (
select Tablename from tablelist)

    --Insert the SchemaName which are not present in Schemalist Table 
	insert into [Config].SchemaList(SchemaName)
	SELECT distinct TABLE_SCHEMA FROM [Config].[Metadata_Source_schema] WHERE TABLE_SCHEMA NOT IN (
select SchemaName from SchemaList)


Declare @val nVarchar(MAX); 
Declare @StoredProc_call nVarchar(MAX); 
 

Select @val = COALESCE(@val + ',' + concat(Table_Schema,'.',TABLE_NAME), concat(Table_Schema,'.',TABLE_NAME)) from
        (select distinct TABLE_SCHEMA,TABLE_NAME From [Config].[Metadata_Source_schema])a;

		-- Calling the sp where datapipeline and pipelinemetdata tables data get inserted.
		select @StoredProc_call=concat('EXEC [Config].USP_Insert_pipelinemetadata ',@DataPipeline_ID,',''',@val,''',''',@val,'''')
		select @StoredProc_call


		--exec @StoredProc_call

END
GO


-----------------------------------------------------------------
/****** Object:  StoredProcedure [dbo].[sp_getDataQualityRules]    Script Date: 3/13/2025 11:40:01 AM ******/
DROP PROCEDURE [dbo].[sp_getDataQualityRules]
GO

/****** Object:  StoredProcedure [dbo].[sp_getDataQualityRules]    Script Date: 3/13/2025 11:40:01 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[sp_getDataQualityRules]        
  @Integration_ID INT  ,
  @Execution_ID INT
AS        
BEGIN        
              
select distinct vm.RuleGroup,ve.ExecutionID,vr.Description,ve.TableName as TableName,ve.ColumnName as ColumnName,vm.ValidationErrorColumn as Identifier,ve.ColumnID as IdentifierValue,'Stage' as DatabaseName,getdate() as [CurrentTimestamp]
from [Config].ValidationRule vr
join [Config].ValidationRuleMapping vm on vr.RuleID=vm.RuleID
join [Config].ValidationError ve on ve.RuleGroup=vm.RuleGroup where Integration_ID=@Integration_ID AND VE.ExecutionID=@Execution_ID
Union all
select distinct vm.RuleGroup,ve.ExecutionID,vr.Description,ve.TableName as TableName,ve.ColumnName as ColumnName,vm.ValidationErrorColumn as Identifier,ve.ColumnID as IdentifierValue,'cmt_in' as DatabaseName,getdate() as [CurrentTimestamp]
from [Config].ValidationRule vr
join [Config].DataValidationRules vm on vr.RuleID=vm.RuleID
join [Config].DataValidationError ve on ve.RuleGroup=vm.RuleGroup where Integration_ID=@Integration_ID AND VE.ExecutionID=@Execution_ID
       
END


GO


